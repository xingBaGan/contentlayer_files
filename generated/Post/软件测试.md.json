{
  "title": "软件测试流程",
  "date": "2022-10-03T00:00:00.000Z",
  "tags": [
    "软件测试",
    "开发流程"
  ],
  "body": {
    "raw": "在真实的工程实践中，不同的软件项目在研发生命周期的各个阶段都会有**不同的测试类型**。\n\n软件模块集成阶段会有代码级**集成测试**，打包部署后会有面向终端用户的 **GUI 测试**；\n\n再比如，电商网站的测试会分为服务器端基于 API 的测试、中间件测试、前端 GUI 测试等\n\n## 测试过程\n\n传统测试过程：\n\n```mermaid\ngraph LR\n    需求评审-->设计评审-->单元测试-->集成测试-->系统测试-->验收测试\n```\n\n```mermaid\ngraph LR\n    计划-->评审-->测试执行-->结果分析评估-->continue-->测试报告\n```\n\n| 阶段                 | 输入和要求                                                   | 输出                                                         |\n| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| Requirement review   | 市场产品需求定义，分析文档和相关技术文档                     | 问题列表，批准需求分析文档。测试计划书起草。                 |\n| Design Review        | 产品规格设计说明，测试计划和测试用例。                       | 功能的测试计划和测试用例                                     |\n| Unit testing.        | 原程序编程规范**产品规格设计说明书**和详细**程序设计文档**。 | 缺陷报告，跟踪报告；完善的测试用例与计划。                   |\n| Integration testing. | 通过单元测试的模块或组件，编程规范，程序设计文档，系统设计文档。 | 权限报告跟踪报告完善的测试用例测试计划。集成测试分析报告，集成后的系统。 |\n| System testing.      | 代码软件包系统设计说明书测试计划，系统测试用例，测试环境等。 | 专业报告系统性能可靠性的分析报告缺陷报告，阶段性测试报告。   |\n| Acceptance testing.  | 产品规格设计说明预发布的软件包确认测试用例。用户要参与验收测试，包括阿尔法贝塔测试。 | 用户验收报告，缺陷报告，版本审查。最终测试报告               |\n\n\n\n在单元测试中需要编写桩程序，即被测试【上层】模块调用的，得到相应的数据。\n\n反之调用测试模块的为驱动程序。\n\n\n\n你不仅需要从业务本身出发来对软件进行**手工测试验证**，\n\n还需要掌握完整的**自动化测试开发**技术来设计自动化测试用例。\n\n```mermaid\ngraph TD\n\t驱动程序 --> 被测模块\n    被测模块 --> mock代码\n    被测模块--> 桩程序1\n```\n\n\n\n你必须系统性地思考如何才能将测试数据的准备**工具化，服务化**，最终实现平台化。\n\n## 测试分类\n\n\n\n压力、性能（响应时间）、安全性、兼容性、易用性\n\n有界面需要做 GUI 测试，在网页中包括是否为\n\n## 单元测试\n\n单元测试的用例是一个“输入数据”和“预计输出”的集合。\n\n在明确了代码需要实现的逻辑功能的基础上，什么输入，应该产生什么输出。\n\n①单元测试总共四个阶段： setup ,exercise,verify, teardown\n\n分别做 准备，执行，验证，拆卸【垃圾回收可能会帮你做】\n\n\n\n，如果没有明确的预计输出，那么测试本身就失去了意 义。同样地，“预计输出” 绝对不是只有函数返回值这么简单，还应该包括函数执行完成 后所改写的所有数据。 \n\n\n\n桩代码的应用首先起到了隔离和补齐的作用，使被测代码能够独立编 译、链接，并独立运行。同时，桩代码还具有控制被测函数执行路径的作用。\n\n\n\n总结：单元测试是对软件中的最小可测试单元在与软件**其他部分相隔离**的情况下进行的代码级测试；\n\n## 自动化测试\n\n对于一些中长期项目，我的建议是：对比较稳定的软件功能进行自动化测试，对变 动较大或者需求暂时不明确的功能进行手工测试，最终目标是用 20% 的精力去覆盖 80% 的回归测试。\n\n软件产品比软件项目更适合做自动化测试\n\n需要在多种平台上重复运行相同测试的场景。\n\n某些测试项目通过手工测试**无法实现**，或者手工成本太高。\n\n被测软件的开发较为规范，能够保证系统的**可测试性**。\n\n某些用例的自动化必须要求开发人员在产品中**预留可测试性接口，否则后续的自动化** 会很难开展。\n\n\n\n单元测试阶段的“自动化”内涵不仅仅指测试用例执行的自动化，还应该包含以 下五个方面：\n\n1. 用例框架代码生成的自动化； 2. 部分测试输入数据的自动化生成； 3. 自动桩代码的生成； 4. 被测代码的自动化**静态分析**； 5. 测试**覆盖率的自动统计与分析**。\n\n## 白盒测试\n\n* 分支覆盖保证语句覆盖 【保证--> 强于】\n* 条件覆盖一般强于分支覆盖\n* 组合条件覆盖强于分支与条件覆盖\n\n分支为走不同的流程。\n\n可以将不同部分为模块测试。\n\n* 逻辑驱动法\n  * 分支覆盖\n  * 条件覆盖\n  * 条件路径覆盖\n\n* 基本路径测试方法\n\n  1. 程序流程图\n\n  2. 计算程序环境复杂\n\n  3. 确定基本路径\n\n     使用到图形矩阵\n\n## 的黑盒测试方法\n\n是等价类划分和边界值分析方法\n\n\n\n例：“用户登录” === 功能性测试\n\n\n\n已经/未注册\n\n输入正确/错误用户名\n\n正确/错误密码\n\n\n\n结果：登录成功/失败\n\n```mermaid\ngraph TB\n    A --> C\n    A --> D\n    B --> C\n    B --> D\n```\n\n\n\n验证码正确/失败\n\n其他问题：\n\n* 大小写敏感，\n* 界面 : 密 码加密\n* 权限问题\n* tab,Enter 是否可用\n* 其他功能问题：限制长度，pattern要求\n\n\n\n测试需要根据需求分析报告功能来设计测试用例。显示功能性需求。\n\n非功能性需求:主要涉及安全性，性能及兼容性三大方面。\n\n* 安全性【安全性】\n\n例如：在web应用下：\n\n在用户名和密码输入框中分别输入典型的sql注入攻击字符串。\n\n或者输入典型的xs跨站脚本攻击。\n\n连续多次登录失败，系统是否会阻止尝试？\n\n同一用户在同一终端多个浏览器上登录，以及同一用户在多台终端浏览器上登录。是否具有互斥性？\n\n* 性能 【服务器】\n\n正常与极端情况下的响应时间。\n\n并发场景下服务器监控指标，死锁与不合理资源等待。\n\n\n\n* 兼容性测试\n\n不同浏览器，不同设备，不同版本验证页面显示是否正常\n\n不同分辨率，显示以及功能是否正确。\n\n\n\n“穷尽测试”是指**包含了软件输入值和前提条件**所有**可能组合**的测试方法，\n\n完成穷尽 测试的系统里应该不残留任何未知的软件缺陷。\n\n是采用基于风险驱动的模式，**有所侧重地选择测试范围和设计测试** 用例，以寻求缺陷风险和研发成本之间的平衡。\n\n## 测试用例\n\n记住：测试用例是用来保证功能完善性。\n\n“好的”测试用例一定是一个**完备的集合**，它能够**覆盖 所有等价类以及各种边界值**，而跟能否发现缺陷无关。 测试用例是你在正确划分基础上的输入集合。\n\n何为正确的划分？\n\n1. 整体完备性： “好的”测试用例一定是一个完备的整体，是有效测试用例组成的集合， 能够完全覆盖测试需求。【包括所有人】\n\n2. 等价类划分的**准确性**： 指的是对于每个等价类都能保证只要其中一个输入测试通过，其他输入也一定测试通过。 【需要选出一个代表】\n3. 等价类集合的**完备性**： 需要保证所有可能的边界值和边界条件都已经正确识别。【包括所有阶级】\n\n如等价类划分法、边界值分析法、错误推测方法、因果图方法、判定表驱动分析法、正交实验设计方法、功能图分析方法、场景设计方法、形式化方 法、扩展有限状态机方法等等，\n\n等价类划分、边界值分析和错误推测这三大类方法就足够了：\n\n例：0~100 成绩输入系统\n\n①等价类划分：\n\n根据拥护可能输入的所有情况\n\n* 数字\n  * 0~100整数\n    * 0~59\n    * 60~100\n  * 其他实数\n    * 浮点数\n  * 其他整数\n* 字符\n\n②边界值分析：\n\n* 得到所有测试用例\n\n③错误推测方法\n\n错误推测方法是指基于对被测试软件系统设计的理解、过往经验以及个人直觉，推测出软件 可能存在的缺陷，从而有针对性地设计测试用例的方法。\n\n这个方法强调的是对被测试软件的 需求理解以及设计实现的**细节把握**，当然还有**个人的能力**。\n\n\n\n\n\n在软件企业的具体实践中，为了降低对个人能力的依赖，通常会建立常**见缺陷知识库**，在测 试设计的过程中，会使用缺陷知识库作为检查点列表（checklist），去帮助优化补充测试 用例的设计。\n\n\n\n面向终端用户的 **GUI 测试**，最核心的测试点就是验证软件对需求的满足程度，这就要求测 试工程师对被测软件的**需求有深入的理解**。\n\n在我看来，深入理解被测软件需求的最好方法 是，测试工程师在需求分析和设计阶段就开始介入，因为这个阶段是**理解和掌握软件**的原始 业务需求的最好时机。\n\n\n\n可能**从业务需求的角度**去设计针对性明确、从终端用户使用场景考虑的端到端（End-2-End）的测试用例集。\n\n总结：\n\n1. 只有深入理解被测试**软件的架构**，你才能设计出“有的放矢”的测试用例集，去发现系 统边界以及系统集成上的潜在缺陷。\n2.  必须深入理解被测软件的设计与实现细节，深入理解**软件内部的处理逻辑**。\n3. . 需要引入需求覆盖率和代码覆盖率来衡量测试执行的**完备性**，并以此为依据来找出遗漏的测试点。",
    "html": "<p>在真实的工程实践中，不同的软件项目在研发生命周期的各个阶段都会有<strong>不同的测试类型</strong>。</p>\n<p>软件模块集成阶段会有代码级<strong>集成测试</strong>，打包部署后会有面向终端用户的 <strong>GUI 测试</strong>；</p>\n<p>再比如，电商网站的测试会分为服务器端基于 API 的测试、中间件测试、前端 GUI 测试等</p>\n<h2>测试过程</h2>\n<p>传统测试过程：</p>\n<pre><code class=\"language-mermaid\">graph LR\n    需求评审-->设计评审-->单元测试-->集成测试-->系统测试-->验收测试\n</code></pre>\n<pre><code class=\"language-mermaid\">graph LR\n    计划-->评审-->测试执行-->结果分析评估-->continue-->测试报告\n</code></pre>\n<p>| 阶段                 | 输入和要求                                                   | 输出                                                         |\n| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| Requirement review   | 市场产品需求定义，分析文档和相关技术文档                     | 问题列表，批准需求分析文档。测试计划书起草。                 |\n| Design Review        | 产品规格设计说明，测试计划和测试用例。                       | 功能的测试计划和测试用例                                     |\n| Unit testing.        | 原程序编程规范<strong>产品规格设计说明书</strong>和详细<strong>程序设计文档</strong>。 | 缺陷报告，跟踪报告；完善的测试用例与计划。                   |\n| Integration testing. | 通过单元测试的模块或组件，编程规范，程序设计文档，系统设计文档。 | 权限报告跟踪报告完善的测试用例测试计划。集成测试分析报告，集成后的系统。 |\n| System testing.      | 代码软件包系统设计说明书测试计划，系统测试用例，测试环境等。 | 专业报告系统性能可靠性的分析报告缺陷报告，阶段性测试报告。   |\n| Acceptance testing.  | 产品规格设计说明预发布的软件包确认测试用例。用户要参与验收测试，包括阿尔法贝塔测试。 | 用户验收报告，缺陷报告，版本审查。最终测试报告               |</p>\n<p>在单元测试中需要编写桩程序，即被测试【上层】模块调用的，得到相应的数据。</p>\n<p>反之调用测试模块的为驱动程序。</p>\n<p>你不仅需要从业务本身出发来对软件进行<strong>手工测试验证</strong>，</p>\n<p>还需要掌握完整的<strong>自动化测试开发</strong>技术来设计自动化测试用例。</p>\n<pre><code class=\"language-mermaid\">graph TD\n\t驱动程序 --> 被测模块\n    被测模块 --> mock代码\n    被测模块--> 桩程序1\n</code></pre>\n<p>你必须系统性地思考如何才能将测试数据的准备<strong>工具化，服务化</strong>，最终实现平台化。</p>\n<h2>测试分类</h2>\n<p>压力、性能（响应时间）、安全性、兼容性、易用性</p>\n<p>有界面需要做 GUI 测试，在网页中包括是否为</p>\n<h2>单元测试</h2>\n<p>单元测试的用例是一个“输入数据”和“预计输出”的集合。</p>\n<p>在明确了代码需要实现的逻辑功能的基础上，什么输入，应该产生什么输出。</p>\n<p>①单元测试总共四个阶段： setup ,exercise,verify, teardown</p>\n<p>分别做 准备，执行，验证，拆卸【垃圾回收可能会帮你做】</p>\n<p>，如果没有明确的预计输出，那么测试本身就失去了意 义。同样地，“预计输出” 绝对不是只有函数返回值这么简单，还应该包括函数执行完成 后所改写的所有数据。</p>\n<p>桩代码的应用首先起到了隔离和补齐的作用，使被测代码能够独立编 译、链接，并独立运行。同时，桩代码还具有控制被测函数执行路径的作用。</p>\n<p>总结：单元测试是对软件中的最小可测试单元在与软件<strong>其他部分相隔离</strong>的情况下进行的代码级测试；</p>\n<h2>自动化测试</h2>\n<p>对于一些中长期项目，我的建议是：对比较稳定的软件功能进行自动化测试，对变 动较大或者需求暂时不明确的功能进行手工测试，最终目标是用 20% 的精力去覆盖 80% 的回归测试。</p>\n<p>软件产品比软件项目更适合做自动化测试</p>\n<p>需要在多种平台上重复运行相同测试的场景。</p>\n<p>某些测试项目通过手工测试<strong>无法实现</strong>，或者手工成本太高。</p>\n<p>被测软件的开发较为规范，能够保证系统的<strong>可测试性</strong>。</p>\n<p>某些用例的自动化必须要求开发人员在产品中<strong>预留可测试性接口，否则后续的自动化</strong> 会很难开展。</p>\n<p>单元测试阶段的“自动化”内涵不仅仅指测试用例执行的自动化，还应该包含以 下五个方面：</p>\n<ol>\n<li>用例框架代码生成的自动化； 2. 部分测试输入数据的自动化生成； 3. 自动桩代码的生成； 4. 被测代码的自动化<strong>静态分析</strong>； 5. 测试<strong>覆盖率的自动统计与分析</strong>。</li>\n</ol>\n<h2>白盒测试</h2>\n<ul>\n<li>分支覆盖保证语句覆盖 【保证--> 强于】</li>\n<li>条件覆盖一般强于分支覆盖</li>\n<li>组合条件覆盖强于分支与条件覆盖</li>\n</ul>\n<p>分支为走不同的流程。</p>\n<p>可以将不同部分为模块测试。</p>\n<ul>\n<li>\n<p>逻辑驱动法</p>\n<ul>\n<li>分支覆盖</li>\n<li>条件覆盖</li>\n<li>条件路径覆盖</li>\n</ul>\n</li>\n<li>\n<p>基本路径测试方法</p>\n<ol>\n<li>\n<p>程序流程图</p>\n</li>\n<li>\n<p>计算程序环境复杂</p>\n</li>\n<li>\n<p>确定基本路径</p>\n<p>使用到图形矩阵</p>\n</li>\n</ol>\n</li>\n</ul>\n<h2>的黑盒测试方法</h2>\n<p>是等价类划分和边界值分析方法</p>\n<p>例：“用户登录” === 功能性测试</p>\n<p>已经/未注册</p>\n<p>输入正确/错误用户名</p>\n<p>正确/错误密码</p>\n<p>结果：登录成功/失败</p>\n<pre><code class=\"language-mermaid\">graph TB\n    A --> C\n    A --> D\n    B --> C\n    B --> D\n</code></pre>\n<p>验证码正确/失败</p>\n<p>其他问题：</p>\n<ul>\n<li>大小写敏感，</li>\n<li>界面 : 密 码加密</li>\n<li>权限问题</li>\n<li>tab,Enter 是否可用</li>\n<li>其他功能问题：限制长度，pattern要求</li>\n</ul>\n<p>测试需要根据需求分析报告功能来设计测试用例。显示功能性需求。</p>\n<p>非功能性需求:主要涉及安全性，性能及兼容性三大方面。</p>\n<ul>\n<li>安全性【安全性】</li>\n</ul>\n<p>例如：在web应用下：</p>\n<p>在用户名和密码输入框中分别输入典型的sql注入攻击字符串。</p>\n<p>或者输入典型的xs跨站脚本攻击。</p>\n<p>连续多次登录失败，系统是否会阻止尝试？</p>\n<p>同一用户在同一终端多个浏览器上登录，以及同一用户在多台终端浏览器上登录。是否具有互斥性？</p>\n<ul>\n<li>性能 【服务器】</li>\n</ul>\n<p>正常与极端情况下的响应时间。</p>\n<p>并发场景下服务器监控指标，死锁与不合理资源等待。</p>\n<ul>\n<li>兼容性测试</li>\n</ul>\n<p>不同浏览器，不同设备，不同版本验证页面显示是否正常</p>\n<p>不同分辨率，显示以及功能是否正确。</p>\n<p>“穷尽测试”是指<strong>包含了软件输入值和前提条件</strong>所有<strong>可能组合</strong>的测试方法，</p>\n<p>完成穷尽 测试的系统里应该不残留任何未知的软件缺陷。</p>\n<p>是采用基于风险驱动的模式，<strong>有所侧重地选择测试范围和设计测试</strong> 用例，以寻求缺陷风险和研发成本之间的平衡。</p>\n<h2>测试用例</h2>\n<p>记住：测试用例是用来保证功能完善性。</p>\n<p>“好的”测试用例一定是一个<strong>完备的集合</strong>，它能够<strong>覆盖 所有等价类以及各种边界值</strong>，而跟能否发现缺陷无关。 测试用例是你在正确划分基础上的输入集合。</p>\n<p>何为正确的划分？</p>\n<ol>\n<li>\n<p>整体完备性： “好的”测试用例一定是一个完备的整体，是有效测试用例组成的集合， 能够完全覆盖测试需求。【包括所有人】</p>\n</li>\n<li>\n<p>等价类划分的<strong>准确性</strong>： 指的是对于每个等价类都能保证只要其中一个输入测试通过，其他输入也一定测试通过。 【需要选出一个代表】</p>\n</li>\n<li>\n<p>等价类集合的<strong>完备性</strong>： 需要保证所有可能的边界值和边界条件都已经正确识别。【包括所有阶级】</p>\n</li>\n</ol>\n<p>如等价类划分法、边界值分析法、错误推测方法、因果图方法、判定表驱动分析法、正交实验设计方法、功能图分析方法、场景设计方法、形式化方 法、扩展有限状态机方法等等，</p>\n<p>等价类划分、边界值分析和错误推测这三大类方法就足够了：</p>\n<p>例：0~100 成绩输入系统</p>\n<p>①等价类划分：</p>\n<p>根据拥护可能输入的所有情况</p>\n<ul>\n<li>数字\n<ul>\n<li>0~100整数\n<ul>\n<li>0~59</li>\n<li>60~100</li>\n</ul>\n</li>\n<li>其他实数\n<ul>\n<li>浮点数</li>\n</ul>\n</li>\n<li>其他整数</li>\n</ul>\n</li>\n<li>字符</li>\n</ul>\n<p>②边界值分析：</p>\n<ul>\n<li>得到所有测试用例</li>\n</ul>\n<p>③错误推测方法</p>\n<p>错误推测方法是指基于对被测试软件系统设计的理解、过往经验以及个人直觉，推测出软件 可能存在的缺陷，从而有针对性地设计测试用例的方法。</p>\n<p>这个方法强调的是对被测试软件的 需求理解以及设计实现的<strong>细节把握</strong>，当然还有<strong>个人的能力</strong>。</p>\n<p>在软件企业的具体实践中，为了降低对个人能力的依赖，通常会建立常<strong>见缺陷知识库</strong>，在测 试设计的过程中，会使用缺陷知识库作为检查点列表（checklist），去帮助优化补充测试 用例的设计。</p>\n<p>面向终端用户的 <strong>GUI 测试</strong>，最核心的测试点就是验证软件对需求的满足程度，这就要求测 试工程师对被测软件的<strong>需求有深入的理解</strong>。</p>\n<p>在我看来，深入理解被测软件需求的最好方法 是，测试工程师在需求分析和设计阶段就开始介入，因为这个阶段是<strong>理解和掌握软件</strong>的原始 业务需求的最好时机。</p>\n<p>可能<strong>从业务需求的角度</strong>去设计针对性明确、从终端用户使用场景考虑的端到端（End-2-End）的测试用例集。</p>\n<p>总结：</p>\n<ol>\n<li>只有深入理解被测试<strong>软件的架构</strong>，你才能设计出“有的放矢”的测试用例集，去发现系 统边界以及系统集成上的潜在缺陷。</li>\n<li>必须深入理解被测软件的设计与实现细节，深入理解<strong>软件内部的处理逻辑</strong>。</li>\n<li>. 需要引入需求覆盖率和代码覆盖率来衡量测试执行的<strong>完备性</strong>，并以此为依据来找出遗漏的测试点。</li>\n</ol>"
  },
  "_id": "软件测试.md",
  "_raw": {
    "sourceFilePath": "软件测试.md",
    "sourceFileName": "软件测试.md",
    "sourceFileDir": ".",
    "contentType": "markdown",
    "flattenedPath": "软件测试"
  },
  "type": "Post",
  "readingTime": {
    "text": "14 min read",
    "minutes": 13.48,
    "time": 808800,
    "words": 2696
  },
  "slug": "软件测试",
  "path": "软件测试",
  "filePath": "软件测试.md",
  "toc": [
    {
      "value": "测试过程",
      "url": "#测试过程",
      "depth": 2
    },
    {
      "value": "测试分类",
      "url": "#测试分类",
      "depth": 2
    },
    {
      "value": "单元测试",
      "url": "#单元测试",
      "depth": 2
    },
    {
      "value": "自动化测试",
      "url": "#自动化测试",
      "depth": 2
    },
    {
      "value": "白盒测试",
      "url": "#白盒测试",
      "depth": 2
    },
    {
      "value": "的黑盒测试方法",
      "url": "#的黑盒测试方法",
      "depth": 2
    },
    {
      "value": "测试用例",
      "url": "#测试用例",
      "depth": 2
    }
  ],
  "structuredData": {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "软件测试流程",
    "datePublished": "2022-10-03T00:00:00.000Z",
    "dateModified": "2022-10-03T00:00:00.000Z",
    "image": "/static/images/twitter-card.png",
    "url": "https://tailwind-nextjs-starter-blog.vercel.app/软件测试"
  }
}